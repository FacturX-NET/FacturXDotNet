//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */

// ReSharper disable InconsistentNaming

export class ApplicableHeaderTradeAgreement implements IApplicableHeaderTradeAgreement {
  buyerReference?: string | undefined;
  sellerTradeParty?: SellerTradeParty | undefined;
  buyerTradeParty?: BuyerTradeParty | undefined;
  buyerOrderReferencedDocument?: BuyerOrderReferencedDocument | undefined;

  [key: string]: any;

  constructor(data?: IApplicableHeaderTradeAgreement) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
      this.sellerTradeParty = data.sellerTradeParty && !(<any>data.sellerTradeParty).toJSON ? new SellerTradeParty(data.sellerTradeParty) : <SellerTradeParty>this.sellerTradeParty;
      this.buyerTradeParty = data.buyerTradeParty && !(<any>data.buyerTradeParty).toJSON ? new BuyerTradeParty(data.buyerTradeParty) : <BuyerTradeParty>this.buyerTradeParty;
      this.buyerOrderReferencedDocument =
        data.buyerOrderReferencedDocument && !(<any>data.buyerOrderReferencedDocument).toJSON
          ? new BuyerOrderReferencedDocument(data.buyerOrderReferencedDocument)
          : <BuyerOrderReferencedDocument>this.buyerOrderReferencedDocument;
    }
  }

  init(_data?: any) {
    if (_data) {
      for (var property in _data) {
        if (_data.hasOwnProperty(property)) this[property] = _data[property];
      }
      this.buyerReference = _data['buyerReference'];
      this.sellerTradeParty = _data['sellerTradeParty'] ? SellerTradeParty.fromJS(_data['sellerTradeParty']) : <any>undefined;
      this.buyerTradeParty = _data['buyerTradeParty'] ? BuyerTradeParty.fromJS(_data['buyerTradeParty']) : <any>undefined;
      this.buyerOrderReferencedDocument = _data['buyerOrderReferencedDocument'] ? BuyerOrderReferencedDocument.fromJS(_data['buyerOrderReferencedDocument']) : <any>undefined;
    }
  }

  static fromJS(data: any): ApplicableHeaderTradeAgreement {
    data = typeof data === 'object' ? data : {};
    let result = new ApplicableHeaderTradeAgreement();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    for (var property in this) {
      if (this.hasOwnProperty(property)) data[property] = this[property];
    }
    data['buyerReference'] = this.buyerReference;
    data['sellerTradeParty'] = this.sellerTradeParty ? this.sellerTradeParty.toJSON() : <any>undefined;
    data['buyerTradeParty'] = this.buyerTradeParty ? this.buyerTradeParty.toJSON() : <any>undefined;
    data['buyerOrderReferencedDocument'] = this.buyerOrderReferencedDocument ? this.buyerOrderReferencedDocument.toJSON() : <any>undefined;
    return data;
  }
}

export interface IApplicableHeaderTradeAgreement {
  buyerReference?: string | undefined;
  sellerTradeParty?: ISellerTradeParty | undefined;
  buyerTradeParty?: IBuyerTradeParty | undefined;
  buyerOrderReferencedDocument?: IBuyerOrderReferencedDocument | undefined;

  [key: string]: any;
}

export class ApplicableHeaderTradeDelivery implements IApplicableHeaderTradeDelivery {
  [key: string]: any;

  constructor(data?: IApplicableHeaderTradeDelivery) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      for (var property in _data) {
        if (_data.hasOwnProperty(property)) this[property] = _data[property];
      }
    }
  }

  static fromJS(data: any): ApplicableHeaderTradeDelivery {
    data = typeof data === 'object' ? data : {};
    let result = new ApplicableHeaderTradeDelivery();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    for (var property in this) {
      if (this.hasOwnProperty(property)) data[property] = this[property];
    }
    return data;
  }
}

export interface IApplicableHeaderTradeDelivery {
  [key: string]: any;
}

export class ApplicableHeaderTradeSettlement implements IApplicableHeaderTradeSettlement {
  invoiceCurrencyCode?: string | undefined;
  specifiedTradeSettlementHeaderMonetarySummation?: SpecifiedTradeSettlementHeaderMonetarySummation | undefined;

  [key: string]: any;

  constructor(data?: IApplicableHeaderTradeSettlement) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
      this.specifiedTradeSettlementHeaderMonetarySummation =
        data.specifiedTradeSettlementHeaderMonetarySummation && !(<any>data.specifiedTradeSettlementHeaderMonetarySummation).toJSON
          ? new SpecifiedTradeSettlementHeaderMonetarySummation(data.specifiedTradeSettlementHeaderMonetarySummation)
          : <SpecifiedTradeSettlementHeaderMonetarySummation>this.specifiedTradeSettlementHeaderMonetarySummation;
    }
  }

  init(_data?: any) {
    if (_data) {
      for (var property in _data) {
        if (_data.hasOwnProperty(property)) this[property] = _data[property];
      }
      this.invoiceCurrencyCode = _data['invoiceCurrencyCode'];
      this.specifiedTradeSettlementHeaderMonetarySummation = _data['specifiedTradeSettlementHeaderMonetarySummation']
        ? SpecifiedTradeSettlementHeaderMonetarySummation.fromJS(_data['specifiedTradeSettlementHeaderMonetarySummation'])
        : <any>undefined;
    }
  }

  static fromJS(data: any): ApplicableHeaderTradeSettlement {
    data = typeof data === 'object' ? data : {};
    let result = new ApplicableHeaderTradeSettlement();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    for (var property in this) {
      if (this.hasOwnProperty(property)) data[property] = this[property];
    }
    data['invoiceCurrencyCode'] = this.invoiceCurrencyCode;
    data['specifiedTradeSettlementHeaderMonetarySummation'] = this.specifiedTradeSettlementHeaderMonetarySummation
      ? this.specifiedTradeSettlementHeaderMonetarySummation.toJSON()
      : <any>undefined;
    return data;
  }
}

export interface IApplicableHeaderTradeSettlement {
  invoiceCurrencyCode?: string | undefined;
  specifiedTradeSettlementHeaderMonetarySummation?: ISpecifiedTradeSettlementHeaderMonetarySummation | undefined;

  [key: string]: any;
}

export class AttachmentDto implements IAttachmentDto {
  file!: string;
  description?: string | undefined;

  [key: string]: any;

  constructor(data?: IAttachmentDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      for (var property in _data) {
        if (_data.hasOwnProperty(property)) this[property] = _data[property];
      }
      this.file = _data['file'];
      this.description = _data['description'];
    }
  }

  static fromJS(data: any): AttachmentDto {
    data = typeof data === 'object' ? data : {};
    let result = new AttachmentDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    for (var property in this) {
      if (this.hasOwnProperty(property)) data[property] = this[property];
    }
    data['file'] = this.file;
    data['description'] = this.description;
    return data;
  }
}

export interface IAttachmentDto {
  file: string;
  description?: string | undefined;

  [key: string]: any;
}

export class BuildInformationDto implements IBuildInformationDto {
  version!: string;
  buildDate!: string;

  [key: string]: any;

  constructor(data?: IBuildInformationDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      for (var property in _data) {
        if (_data.hasOwnProperty(property)) this[property] = _data[property];
      }
      this.version = _data['version'];
      this.buildDate = _data['buildDate'];
    }
  }

  static fromJS(data: any): BuildInformationDto {
    data = typeof data === 'object' ? data : {};
    let result = new BuildInformationDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    for (var property in this) {
      if (this.hasOwnProperty(property)) data[property] = this[property];
    }
    data['version'] = this.version;
    data['buildDate'] = this.buildDate;
    return data;
  }
}

export interface IBuildInformationDto {
  version: string;
  buildDate: string;

  [key: string]: any;
}

export class BuyerOrderReferencedDocument implements IBuyerOrderReferencedDocument {
  issuerAssignedId?: string | undefined;

  [key: string]: any;

  constructor(data?: IBuyerOrderReferencedDocument) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      for (var property in _data) {
        if (_data.hasOwnProperty(property)) this[property] = _data[property];
      }
      this.issuerAssignedId = _data['issuerAssignedId'];
    }
  }

  static fromJS(data: any): BuyerOrderReferencedDocument {
    data = typeof data === 'object' ? data : {};
    let result = new BuyerOrderReferencedDocument();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    for (var property in this) {
      if (this.hasOwnProperty(property)) data[property] = this[property];
    }
    data['issuerAssignedId'] = this.issuerAssignedId;
    return data;
  }
}

export interface IBuyerOrderReferencedDocument {
  issuerAssignedId?: string | undefined;

  [key: string]: any;
}

export class BuyerTradeParty implements IBuyerTradeParty {
  name?: string | undefined;
  specifiedLegalOrganization?: BuyerTradePartySpecifiedLegalOrganization | undefined;

  [key: string]: any;

  constructor(data?: IBuyerTradeParty) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
      this.specifiedLegalOrganization =
        data.specifiedLegalOrganization && !(<any>data.specifiedLegalOrganization).toJSON
          ? new BuyerTradePartySpecifiedLegalOrganization(data.specifiedLegalOrganization)
          : <BuyerTradePartySpecifiedLegalOrganization>this.specifiedLegalOrganization;
    }
  }

  init(_data?: any) {
    if (_data) {
      for (var property in _data) {
        if (_data.hasOwnProperty(property)) this[property] = _data[property];
      }
      this.name = _data['name'];
      this.specifiedLegalOrganization = _data['specifiedLegalOrganization']
        ? BuyerTradePartySpecifiedLegalOrganization.fromJS(_data['specifiedLegalOrganization'])
        : <any>undefined;
    }
  }

  static fromJS(data: any): BuyerTradeParty {
    data = typeof data === 'object' ? data : {};
    let result = new BuyerTradeParty();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    for (var property in this) {
      if (this.hasOwnProperty(property)) data[property] = this[property];
    }
    data['name'] = this.name;
    data['specifiedLegalOrganization'] = this.specifiedLegalOrganization ? this.specifiedLegalOrganization.toJSON() : <any>undefined;
    return data;
  }
}

export interface IBuyerTradeParty {
  name?: string | undefined;
  specifiedLegalOrganization?: IBuyerTradePartySpecifiedLegalOrganization | undefined;

  [key: string]: any;
}

export class BuyerTradePartySpecifiedLegalOrganization implements IBuyerTradePartySpecifiedLegalOrganization {
  id?: string | undefined;
  idSchemeId?: string | undefined;

  [key: string]: any;

  constructor(data?: IBuyerTradePartySpecifiedLegalOrganization) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      for (var property in _data) {
        if (_data.hasOwnProperty(property)) this[property] = _data[property];
      }
      this.id = _data['id'];
      this.idSchemeId = _data['idSchemeId'];
    }
  }

  static fromJS(data: any): BuyerTradePartySpecifiedLegalOrganization {
    data = typeof data === 'object' ? data : {};
    let result = new BuyerTradePartySpecifiedLegalOrganization();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    for (var property in this) {
      if (this.hasOwnProperty(property)) data[property] = this[property];
    }
    data['id'] = this.id;
    data['idSchemeId'] = this.idSchemeId;
    return data;
  }
}

export interface IBuyerTradePartySpecifiedLegalOrganization {
  id?: string | undefined;
  idSchemeId?: string | undefined;

  [key: string]: any;
}

export class CrossIndustryInvoice implements ICrossIndustryInvoice {
  exchangedDocumentContext?: ExchangedDocumentContext | undefined;
  exchangedDocument?: ExchangedDocument | undefined;
  supplyChainTradeTransaction?: SupplyChainTradeTransaction | undefined;

  [key: string]: any;

  constructor(data?: ICrossIndustryInvoice) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
      this.exchangedDocumentContext =
        data.exchangedDocumentContext && !(<any>data.exchangedDocumentContext).toJSON
          ? new ExchangedDocumentContext(data.exchangedDocumentContext)
          : <ExchangedDocumentContext>this.exchangedDocumentContext;
      this.exchangedDocument =
        data.exchangedDocument && !(<any>data.exchangedDocument).toJSON ? new ExchangedDocument(data.exchangedDocument) : <ExchangedDocument>this.exchangedDocument;
      this.supplyChainTradeTransaction =
        data.supplyChainTradeTransaction && !(<any>data.supplyChainTradeTransaction).toJSON
          ? new SupplyChainTradeTransaction(data.supplyChainTradeTransaction)
          : <SupplyChainTradeTransaction>this.supplyChainTradeTransaction;
    }
  }

  init(_data?: any) {
    if (_data) {
      for (var property in _data) {
        if (_data.hasOwnProperty(property)) this[property] = _data[property];
      }
      this.exchangedDocumentContext = _data['exchangedDocumentContext'] ? ExchangedDocumentContext.fromJS(_data['exchangedDocumentContext']) : <any>undefined;
      this.exchangedDocument = _data['exchangedDocument'] ? ExchangedDocument.fromJS(_data['exchangedDocument']) : <any>undefined;
      this.supplyChainTradeTransaction = _data['supplyChainTradeTransaction'] ? SupplyChainTradeTransaction.fromJS(_data['supplyChainTradeTransaction']) : <any>undefined;
    }
  }

  static fromJS(data: any): CrossIndustryInvoice {
    data = typeof data === 'object' ? data : {};
    let result = new CrossIndustryInvoice();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    for (var property in this) {
      if (this.hasOwnProperty(property)) data[property] = this[property];
    }
    data['exchangedDocumentContext'] = this.exchangedDocumentContext ? this.exchangedDocumentContext.toJSON() : <any>undefined;
    data['exchangedDocument'] = this.exchangedDocument ? this.exchangedDocument.toJSON() : <any>undefined;
    data['supplyChainTradeTransaction'] = this.supplyChainTradeTransaction ? this.supplyChainTradeTransaction.toJSON() : <any>undefined;
    return data;
  }
}

export interface ICrossIndustryInvoice {
  exchangedDocumentContext?: IExchangedDocumentContext | undefined;
  exchangedDocument?: IExchangedDocument | undefined;
  supplyChainTradeTransaction?: ISupplyChainTradeTransaction | undefined;

  [key: string]: any;
}

export class ExchangedDocument implements IExchangedDocument {
  id?: string | undefined;
  typeCode?: InvoiceTypeCode | undefined;
  issueDateTime?: string | undefined;
  issueDateTimeFormat?: DateOnlyFormat | undefined;

  [key: string]: any;

  constructor(data?: IExchangedDocument) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      for (var property in _data) {
        if (_data.hasOwnProperty(property)) this[property] = _data[property];
      }
      this.id = _data['id'];
      this.typeCode = _data['typeCode'];
      this.issueDateTime = _data['issueDateTime'];
      this.issueDateTimeFormat = _data['issueDateTimeFormat'];
    }
  }

  static fromJS(data: any): ExchangedDocument {
    data = typeof data === 'object' ? data : {};
    let result = new ExchangedDocument();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    for (var property in this) {
      if (this.hasOwnProperty(property)) data[property] = this[property];
    }
    data['id'] = this.id;
    data['typeCode'] = this.typeCode;
    data['issueDateTime'] = this.issueDateTime;
    data['issueDateTimeFormat'] = this.issueDateTimeFormat;
    return data;
  }
}

export interface IExchangedDocument {
  id?: string | undefined;
  typeCode?: InvoiceTypeCode | undefined;
  issueDateTime?: string | undefined;
  issueDateTimeFormat?: DateOnlyFormat | undefined;

  [key: string]: any;
}

export class ExchangedDocumentContext implements IExchangedDocumentContext {
  businessProcessSpecifiedDocumentContextParameterId?: string | undefined;
  guidelineSpecifiedDocumentContextParameterId?: GuidelineSpecifiedDocumentContextParameterId | undefined;

  [key: string]: any;

  constructor(data?: IExchangedDocumentContext) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      for (var property in _data) {
        if (_data.hasOwnProperty(property)) this[property] = _data[property];
      }
      this.businessProcessSpecifiedDocumentContextParameterId = _data['businessProcessSpecifiedDocumentContextParameterId'];
      this.guidelineSpecifiedDocumentContextParameterId = _data['guidelineSpecifiedDocumentContextParameterId'];
    }
  }

  static fromJS(data: any): ExchangedDocumentContext {
    data = typeof data === 'object' ? data : {};
    let result = new ExchangedDocumentContext();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    for (var property in this) {
      if (this.hasOwnProperty(property)) data[property] = this[property];
    }
    data['businessProcessSpecifiedDocumentContextParameterId'] = this.businessProcessSpecifiedDocumentContextParameterId;
    data['guidelineSpecifiedDocumentContextParameterId'] = this.guidelineSpecifiedDocumentContextParameterId;
    return data;
  }
}

export interface IExchangedDocumentContext {
  businessProcessSpecifiedDocumentContextParameterId?: string | undefined;
  guidelineSpecifiedDocumentContextParameterId?: GuidelineSpecifiedDocumentContextParameterId | undefined;

  [key: string]: any;
}

export type DateOnlyFormat = 'DateOnly';

export type GuidelineSpecifiedDocumentContextParameterId = 'Minimum' | 'BasicWl' | 'Basic' | 'En16931' | 'Extended';

export type InvoiceTypeCode =
  | 'RequestForPayment'
  | 'DebitNoteRelatedToGoodsOrServices'
  | 'CreditNoteRelatedToGoodsOrServices'
  | 'MeteredServicesInvoice'
  | 'CreditNoteRelatedToFinancialAdjustments'
  | 'DebitNoteRelatedToFinancialAdjustments'
  | 'TaxNotification'
  | 'InvoicingDataSheet'
  | 'DirectPaymentValuation'
  | 'ProvisionalPaymentValuation'
  | 'PaymentValuation'
  | 'InterimApplicationForPayment'
  | 'FinalPaymentRequestBasedOnCompletionOfWork'
  | 'PaymentRequestForCompletedUnits'
  | 'SelfBilledCreditNote'
  | 'ConsolidatedCreditNoteGoodsAndServices'
  | 'PriceVariationInvoice'
  | 'CreditNoteForPriceVariation'
  | 'DelcredereCreditNote'
  | 'ProformaInvoice'
  | 'PartialInvoice'
  | 'CommercialInvoiceWhichIncludesPackingList'
  | 'CommercialInvoice'
  | 'CreditNote'
  | 'CommissionNote'
  | 'DebitNote'
  | 'CorrectedInvoice'
  | 'ConsolidatedInvoice'
  | 'PrepaymentInvoice'
  | 'HireInvoice'
  | 'TaxInvoice'
  | 'SelfBilledInvoice'
  | 'DelcredereInvoice'
  | 'FactoredInvoice'
  | 'LeaseInvoice'
  | 'ConsignmentInvoice'
  | 'FactoredCreditNote'
  | 'OcrPaymentCreditNote'
  | 'DebitAdvice'
  | 'ReversalOfDebit'
  | 'ReversalOfCredit'
  | 'SelfBilledDebitNote'
  | 'ForwardersCreditNote'
  | 'ForwardersInvoiceDiscrepancyReport'
  | 'InsurersInvoice'
  | 'ForwardersInvoice'
  | 'PortChargesDocuments'
  | 'InvoiceInformationForAccountingPurposes'
  | 'FreightInvoice'
  | 'ClaimNotification'
  | 'ConsularInvoice'
  | 'PartialConstructionInvoice'
  | 'PartialFinalConstructionInvoice'
  | 'FinalConstructionInvoice'
  | 'CustomsInvoice';

export type VatOnlyTaxSchemeIdentifier = 'Vat';

export type XmpFacturXConformanceLevel = 'Minimum' | 'BasicWl' | 'Basic' | 'Comfort' | 'En16931' | 'Extended' | 'XRechnung';

export type XmpFacturXDocumentType = 'Invoice' | 'Order';

export type XmpPdfAConformanceLevel = 'A' | 'B';

export type XmpPdfAPropertyCategory = 'Internal' | 'External';

export type XmpThumbnailFormat = 'Jpeg';

export class PackageDto implements IPackageDto {
  name!: string;
  author!: string;
  version!: string;
  license!: string;
  link!: string;

  [key: string]: any;

  constructor(data?: IPackageDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      for (var property in _data) {
        if (_data.hasOwnProperty(property)) this[property] = _data[property];
      }
      this.name = _data['name'];
      this.author = _data['author'];
      this.version = _data['version'];
      this.license = _data['license'];
      this.link = _data['link'];
    }
  }

  static fromJS(data: any): PackageDto {
    data = typeof data === 'object' ? data : {};
    let result = new PackageDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    for (var property in this) {
      if (this.hasOwnProperty(property)) data[property] = this[property];
    }
    data['name'] = this.name;
    data['author'] = this.author;
    data['version'] = this.version;
    data['license'] = this.license;
    data['link'] = this.link;
    return data;
  }
}

export interface IPackageDto {
  name: string;
  author: string;
  version: string;
  license: string;
  link: string;

  [key: string]: any;
}

export class SellerTradeParty implements ISellerTradeParty {
  name?: string | undefined;
  specifiedLegalOrganization?: SellerTradePartySpecifiedLegalOrganization | undefined;
  postalTradeAddress?: SellerTradePartyPostalTradeAddress | undefined;
  specifiedTaxRegistration?: SellerTradePartySpecifiedTaxRegistration | undefined;

  [key: string]: any;

  constructor(data?: ISellerTradeParty) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
      this.specifiedLegalOrganization =
        data.specifiedLegalOrganization && !(<any>data.specifiedLegalOrganization).toJSON
          ? new SellerTradePartySpecifiedLegalOrganization(data.specifiedLegalOrganization)
          : <SellerTradePartySpecifiedLegalOrganization>this.specifiedLegalOrganization;
      this.postalTradeAddress =
        data.postalTradeAddress && !(<any>data.postalTradeAddress).toJSON
          ? new SellerTradePartyPostalTradeAddress(data.postalTradeAddress)
          : <SellerTradePartyPostalTradeAddress>this.postalTradeAddress;
      this.specifiedTaxRegistration =
        data.specifiedTaxRegistration && !(<any>data.specifiedTaxRegistration).toJSON
          ? new SellerTradePartySpecifiedTaxRegistration(data.specifiedTaxRegistration)
          : <SellerTradePartySpecifiedTaxRegistration>this.specifiedTaxRegistration;
    }
  }

  init(_data?: any) {
    if (_data) {
      for (var property in _data) {
        if (_data.hasOwnProperty(property)) this[property] = _data[property];
      }
      this.name = _data['name'];
      this.specifiedLegalOrganization = _data['specifiedLegalOrganization']
        ? SellerTradePartySpecifiedLegalOrganization.fromJS(_data['specifiedLegalOrganization'])
        : <any>undefined;
      this.postalTradeAddress = _data['postalTradeAddress'] ? SellerTradePartyPostalTradeAddress.fromJS(_data['postalTradeAddress']) : <any>undefined;
      this.specifiedTaxRegistration = _data['specifiedTaxRegistration'] ? SellerTradePartySpecifiedTaxRegistration.fromJS(_data['specifiedTaxRegistration']) : <any>undefined;
    }
  }

  static fromJS(data: any): SellerTradeParty {
    data = typeof data === 'object' ? data : {};
    let result = new SellerTradeParty();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    for (var property in this) {
      if (this.hasOwnProperty(property)) data[property] = this[property];
    }
    data['name'] = this.name;
    data['specifiedLegalOrganization'] = this.specifiedLegalOrganization ? this.specifiedLegalOrganization.toJSON() : <any>undefined;
    data['postalTradeAddress'] = this.postalTradeAddress ? this.postalTradeAddress.toJSON() : <any>undefined;
    data['specifiedTaxRegistration'] = this.specifiedTaxRegistration ? this.specifiedTaxRegistration.toJSON() : <any>undefined;
    return data;
  }
}

export interface ISellerTradeParty {
  name?: string | undefined;
  specifiedLegalOrganization?: ISellerTradePartySpecifiedLegalOrganization | undefined;
  postalTradeAddress?: ISellerTradePartyPostalTradeAddress | undefined;
  specifiedTaxRegistration?: ISellerTradePartySpecifiedTaxRegistration | undefined;

  [key: string]: any;
}

export class SellerTradePartyPostalTradeAddress implements ISellerTradePartyPostalTradeAddress {
  countryId?: string | undefined;

  [key: string]: any;

  constructor(data?: ISellerTradePartyPostalTradeAddress) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      for (var property in _data) {
        if (_data.hasOwnProperty(property)) this[property] = _data[property];
      }
      this.countryId = _data['countryId'];
    }
  }

  static fromJS(data: any): SellerTradePartyPostalTradeAddress {
    data = typeof data === 'object' ? data : {};
    let result = new SellerTradePartyPostalTradeAddress();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    for (var property in this) {
      if (this.hasOwnProperty(property)) data[property] = this[property];
    }
    data['countryId'] = this.countryId;
    return data;
  }
}

export interface ISellerTradePartyPostalTradeAddress {
  countryId?: string | undefined;

  [key: string]: any;
}

export class SellerTradePartySpecifiedLegalOrganization implements ISellerTradePartySpecifiedLegalOrganization {
  id?: string | undefined;
  idSchemeId?: string | undefined;

  [key: string]: any;

  constructor(data?: ISellerTradePartySpecifiedLegalOrganization) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      for (var property in _data) {
        if (_data.hasOwnProperty(property)) this[property] = _data[property];
      }
      this.id = _data['id'];
      this.idSchemeId = _data['idSchemeId'];
    }
  }

  static fromJS(data: any): SellerTradePartySpecifiedLegalOrganization {
    data = typeof data === 'object' ? data : {};
    let result = new SellerTradePartySpecifiedLegalOrganization();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    for (var property in this) {
      if (this.hasOwnProperty(property)) data[property] = this[property];
    }
    data['id'] = this.id;
    data['idSchemeId'] = this.idSchemeId;
    return data;
  }
}

export interface ISellerTradePartySpecifiedLegalOrganization {
  id?: string | undefined;
  idSchemeId?: string | undefined;

  [key: string]: any;
}

export class SellerTradePartySpecifiedTaxRegistration implements ISellerTradePartySpecifiedTaxRegistration {
  id?: string | undefined;
  idSchemeId?: VatOnlyTaxSchemeIdentifier | undefined;

  [key: string]: any;

  constructor(data?: ISellerTradePartySpecifiedTaxRegistration) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      for (var property in _data) {
        if (_data.hasOwnProperty(property)) this[property] = _data[property];
      }
      this.id = _data['id'];
      this.idSchemeId = _data['idSchemeId'];
    }
  }

  static fromJS(data: any): SellerTradePartySpecifiedTaxRegistration {
    data = typeof data === 'object' ? data : {};
    let result = new SellerTradePartySpecifiedTaxRegistration();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    for (var property in this) {
      if (this.hasOwnProperty(property)) data[property] = this[property];
    }
    data['id'] = this.id;
    data['idSchemeId'] = this.idSchemeId;
    return data;
  }
}

export interface ISellerTradePartySpecifiedTaxRegistration {
  id?: string | undefined;
  idSchemeId?: VatOnlyTaxSchemeIdentifier | undefined;

  [key: string]: any;
}

export class SpecifiedTradeSettlementHeaderMonetarySummation implements ISpecifiedTradeSettlementHeaderMonetarySummation {
  taxBasisTotalAmount?: number | undefined;
  taxTotalAmount?: number | undefined;
  taxTotalAmountCurrencyId?: string | undefined;
  grandTotalAmount?: number | undefined;
  duePayableAmount?: number | undefined;

  [key: string]: any;

  constructor(data?: ISpecifiedTradeSettlementHeaderMonetarySummation) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      for (var property in _data) {
        if (_data.hasOwnProperty(property)) this[property] = _data[property];
      }
      this.taxBasisTotalAmount = _data['taxBasisTotalAmount'];
      this.taxTotalAmount = _data['taxTotalAmount'];
      this.taxTotalAmountCurrencyId = _data['taxTotalAmountCurrencyId'];
      this.grandTotalAmount = _data['grandTotalAmount'];
      this.duePayableAmount = _data['duePayableAmount'];
    }
  }

  static fromJS(data: any): SpecifiedTradeSettlementHeaderMonetarySummation {
    data = typeof data === 'object' ? data : {};
    let result = new SpecifiedTradeSettlementHeaderMonetarySummation();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    for (var property in this) {
      if (this.hasOwnProperty(property)) data[property] = this[property];
    }
    data['taxBasisTotalAmount'] = this.taxBasisTotalAmount;
    data['taxTotalAmount'] = this.taxTotalAmount;
    data['taxTotalAmountCurrencyId'] = this.taxTotalAmountCurrencyId;
    data['grandTotalAmount'] = this.grandTotalAmount;
    data['duePayableAmount'] = this.duePayableAmount;
    return data;
  }
}

export interface ISpecifiedTradeSettlementHeaderMonetarySummation {
  taxBasisTotalAmount?: number | undefined;
  taxTotalAmount?: number | undefined;
  taxTotalAmountCurrencyId?: string | undefined;
  grandTotalAmount?: number | undefined;
  duePayableAmount?: number | undefined;

  [key: string]: any;
}

export class SupplyChainTradeTransaction implements ISupplyChainTradeTransaction {
  applicableHeaderTradeAgreement?: ApplicableHeaderTradeAgreement | undefined;
  applicableHeaderTradeDelivery?: ApplicableHeaderTradeDelivery | undefined;
  applicableHeaderTradeSettlement?: ApplicableHeaderTradeSettlement | undefined;

  [key: string]: any;

  constructor(data?: ISupplyChainTradeTransaction) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
      this.applicableHeaderTradeAgreement =
        data.applicableHeaderTradeAgreement && !(<any>data.applicableHeaderTradeAgreement).toJSON
          ? new ApplicableHeaderTradeAgreement(data.applicableHeaderTradeAgreement)
          : <ApplicableHeaderTradeAgreement>this.applicableHeaderTradeAgreement;
      this.applicableHeaderTradeDelivery =
        data.applicableHeaderTradeDelivery && !(<any>data.applicableHeaderTradeDelivery).toJSON
          ? new ApplicableHeaderTradeDelivery(data.applicableHeaderTradeDelivery)
          : <ApplicableHeaderTradeDelivery>this.applicableHeaderTradeDelivery;
      this.applicableHeaderTradeSettlement =
        data.applicableHeaderTradeSettlement && !(<any>data.applicableHeaderTradeSettlement).toJSON
          ? new ApplicableHeaderTradeSettlement(data.applicableHeaderTradeSettlement)
          : <ApplicableHeaderTradeSettlement>this.applicableHeaderTradeSettlement;
    }
  }

  init(_data?: any) {
    if (_data) {
      for (var property in _data) {
        if (_data.hasOwnProperty(property)) this[property] = _data[property];
      }
      this.applicableHeaderTradeAgreement = _data['applicableHeaderTradeAgreement']
        ? ApplicableHeaderTradeAgreement.fromJS(_data['applicableHeaderTradeAgreement'])
        : <any>undefined;
      this.applicableHeaderTradeDelivery = _data['applicableHeaderTradeDelivery'] ? ApplicableHeaderTradeDelivery.fromJS(_data['applicableHeaderTradeDelivery']) : <any>undefined;
      this.applicableHeaderTradeSettlement = _data['applicableHeaderTradeSettlement']
        ? ApplicableHeaderTradeSettlement.fromJS(_data['applicableHeaderTradeSettlement'])
        : <any>undefined;
    }
  }

  static fromJS(data: any): SupplyChainTradeTransaction {
    data = typeof data === 'object' ? data : {};
    let result = new SupplyChainTradeTransaction();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    for (var property in this) {
      if (this.hasOwnProperty(property)) data[property] = this[property];
    }
    data['applicableHeaderTradeAgreement'] = this.applicableHeaderTradeAgreement ? this.applicableHeaderTradeAgreement.toJSON() : <any>undefined;
    data['applicableHeaderTradeDelivery'] = this.applicableHeaderTradeDelivery ? this.applicableHeaderTradeDelivery.toJSON() : <any>undefined;
    data['applicableHeaderTradeSettlement'] = this.applicableHeaderTradeSettlement ? this.applicableHeaderTradeSettlement.toJSON() : <any>undefined;
    return data;
  }
}

export interface ISupplyChainTradeTransaction {
  applicableHeaderTradeAgreement?: IApplicableHeaderTradeAgreement | undefined;
  applicableHeaderTradeDelivery?: IApplicableHeaderTradeDelivery | undefined;
  applicableHeaderTradeSettlement?: IApplicableHeaderTradeSettlement | undefined;

  [key: string]: any;
}

export class XmpBasicMetadata implements IXmpBasicMetadata {
  identifier?: string[];
  createDate?: string | undefined;
  creatorTool?: string | undefined;
  label?: string | undefined;
  metadataDate?: string | undefined;
  modifyDate?: string | undefined;
  rating?: number;
  baseUrl?: string | undefined;
  nickname?: string | undefined;
  thumbnails?: XmpThumbnail[];

  [key: string]: any;

  constructor(data?: IXmpBasicMetadata) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
      if (data.thumbnails) {
        this.thumbnails = [];
        for (let i = 0; i < data.thumbnails.length; i++) {
          let item = data.thumbnails[i];
          this.thumbnails[i] = item && !(<any>item).toJSON ? new XmpThumbnail(item) : <XmpThumbnail>item;
        }
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      for (var property in _data) {
        if (_data.hasOwnProperty(property)) this[property] = _data[property];
      }
      if (Array.isArray(_data['identifier'])) {
        this.identifier = [] as any;
        for (let item of _data['identifier']) this.identifier!.push(item);
      }
      this.createDate = _data['createDate'];
      this.creatorTool = _data['creatorTool'];
      this.label = _data['label'];
      this.metadataDate = _data['metadataDate'];
      this.modifyDate = _data['modifyDate'];
      this.rating = _data['rating'];
      this.baseUrl = _data['baseUrl'];
      this.nickname = _data['nickname'];
      if (Array.isArray(_data['thumbnails'])) {
        this.thumbnails = [] as any;
        for (let item of _data['thumbnails']) this.thumbnails!.push(XmpThumbnail.fromJS(item));
      }
    }
  }

  static fromJS(data: any): XmpBasicMetadata {
    data = typeof data === 'object' ? data : {};
    let result = new XmpBasicMetadata();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    for (var property in this) {
      if (this.hasOwnProperty(property)) data[property] = this[property];
    }
    if (Array.isArray(this.identifier)) {
      data['identifier'] = [];
      for (let item of this.identifier) data['identifier'].push(item);
    }
    data['createDate'] = this.createDate;
    data['creatorTool'] = this.creatorTool;
    data['label'] = this.label;
    data['metadataDate'] = this.metadataDate;
    data['modifyDate'] = this.modifyDate;
    data['rating'] = this.rating;
    data['baseUrl'] = this.baseUrl;
    data['nickname'] = this.nickname;
    if (Array.isArray(this.thumbnails)) {
      data['thumbnails'] = [];
      for (let item of this.thumbnails) data['thumbnails'].push(item.toJSON());
    }
    return data;
  }
}

export interface IXmpBasicMetadata {
  identifier?: string[];
  createDate?: string | undefined;
  creatorTool?: string | undefined;
  label?: string | undefined;
  metadataDate?: string | undefined;
  modifyDate?: string | undefined;
  rating?: number;
  baseUrl?: string | undefined;
  nickname?: string | undefined;
  thumbnails?: IXmpThumbnail[];

  [key: string]: any;
}

export class XmpDublinCoreMetadata implements IXmpDublinCoreMetadata {
  contributor?: string[];
  coverage?: string | undefined;
  creator?: string[];
  date?: string[];
  description?: string[];
  format?: string | undefined;
  identifier?: string | undefined;
  language?: string[];
  publisher?: string[];
  relation?: string[];
  rights?: string[];
  source?: string | undefined;
  subject?: string[];
  title?: string[];
  type?: string[];

  [key: string]: any;

  constructor(data?: IXmpDublinCoreMetadata) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      for (var property in _data) {
        if (_data.hasOwnProperty(property)) this[property] = _data[property];
      }
      if (Array.isArray(_data['contributor'])) {
        this.contributor = [] as any;
        for (let item of _data['contributor']) this.contributor!.push(item);
      }
      this.coverage = _data['coverage'];
      if (Array.isArray(_data['creator'])) {
        this.creator = [] as any;
        for (let item of _data['creator']) this.creator!.push(item);
      }
      if (Array.isArray(_data['date'])) {
        this.date = [] as any;
        for (let item of _data['date']) this.date!.push(item);
      }
      if (Array.isArray(_data['description'])) {
        this.description = [] as any;
        for (let item of _data['description']) this.description!.push(item);
      }
      this.format = _data['format'];
      this.identifier = _data['identifier'];
      if (Array.isArray(_data['language'])) {
        this.language = [] as any;
        for (let item of _data['language']) this.language!.push(item);
      }
      if (Array.isArray(_data['publisher'])) {
        this.publisher = [] as any;
        for (let item of _data['publisher']) this.publisher!.push(item);
      }
      if (Array.isArray(_data['relation'])) {
        this.relation = [] as any;
        for (let item of _data['relation']) this.relation!.push(item);
      }
      if (Array.isArray(_data['rights'])) {
        this.rights = [] as any;
        for (let item of _data['rights']) this.rights!.push(item);
      }
      this.source = _data['source'];
      if (Array.isArray(_data['subject'])) {
        this.subject = [] as any;
        for (let item of _data['subject']) this.subject!.push(item);
      }
      if (Array.isArray(_data['title'])) {
        this.title = [] as any;
        for (let item of _data['title']) this.title!.push(item);
      }
      if (Array.isArray(_data['type'])) {
        this.type = [] as any;
        for (let item of _data['type']) this.type!.push(item);
      }
    }
  }

  static fromJS(data: any): XmpDublinCoreMetadata {
    data = typeof data === 'object' ? data : {};
    let result = new XmpDublinCoreMetadata();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    for (var property in this) {
      if (this.hasOwnProperty(property)) data[property] = this[property];
    }
    if (Array.isArray(this.contributor)) {
      data['contributor'] = [];
      for (let item of this.contributor) data['contributor'].push(item);
    }
    data['coverage'] = this.coverage;
    if (Array.isArray(this.creator)) {
      data['creator'] = [];
      for (let item of this.creator) data['creator'].push(item);
    }
    if (Array.isArray(this.date)) {
      data['date'] = [];
      for (let item of this.date) data['date'].push(item);
    }
    if (Array.isArray(this.description)) {
      data['description'] = [];
      for (let item of this.description) data['description'].push(item);
    }
    data['format'] = this.format;
    data['identifier'] = this.identifier;
    if (Array.isArray(this.language)) {
      data['language'] = [];
      for (let item of this.language) data['language'].push(item);
    }
    if (Array.isArray(this.publisher)) {
      data['publisher'] = [];
      for (let item of this.publisher) data['publisher'].push(item);
    }
    if (Array.isArray(this.relation)) {
      data['relation'] = [];
      for (let item of this.relation) data['relation'].push(item);
    }
    if (Array.isArray(this.rights)) {
      data['rights'] = [];
      for (let item of this.rights) data['rights'].push(item);
    }
    data['source'] = this.source;
    if (Array.isArray(this.subject)) {
      data['subject'] = [];
      for (let item of this.subject) data['subject'].push(item);
    }
    if (Array.isArray(this.title)) {
      data['title'] = [];
      for (let item of this.title) data['title'].push(item);
    }
    if (Array.isArray(this.type)) {
      data['type'] = [];
      for (let item of this.type) data['type'].push(item);
    }
    return data;
  }
}

export interface IXmpDublinCoreMetadata {
  contributor?: string[];
  coverage?: string | undefined;
  creator?: string[];
  date?: string[];
  description?: string[];
  format?: string | undefined;
  identifier?: string | undefined;
  language?: string[];
  publisher?: string[];
  relation?: string[];
  rights?: string[];
  source?: string | undefined;
  subject?: string[];
  title?: string[];
  type?: string[];

  [key: string]: any;
}

export class XmpFacturXMetadata implements IXmpFacturXMetadata {
  documentFileName?: string | undefined;
  documentType?: XmpFacturXDocumentType | undefined;
  version?: string | undefined;
  conformanceLevel?: XmpFacturXConformanceLevel | undefined;

  [key: string]: any;

  constructor(data?: IXmpFacturXMetadata) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      for (var property in _data) {
        if (_data.hasOwnProperty(property)) this[property] = _data[property];
      }
      this.documentFileName = _data['documentFileName'];
      this.documentType = _data['documentType'];
      this.version = _data['version'];
      this.conformanceLevel = _data['conformanceLevel'];
    }
  }

  static fromJS(data: any): XmpFacturXMetadata {
    data = typeof data === 'object' ? data : {};
    let result = new XmpFacturXMetadata();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    for (var property in this) {
      if (this.hasOwnProperty(property)) data[property] = this[property];
    }
    data['documentFileName'] = this.documentFileName;
    data['documentType'] = this.documentType;
    data['version'] = this.version;
    data['conformanceLevel'] = this.conformanceLevel;
    return data;
  }
}

export interface IXmpFacturXMetadata {
  documentFileName?: string | undefined;
  documentType?: XmpFacturXDocumentType | undefined;
  version?: string | undefined;
  conformanceLevel?: XmpFacturXConformanceLevel | undefined;

  [key: string]: any;
}

export class XmpMetadata implements IXmpMetadata {
  pdfAIdentification?: XmpPdfAIdentificationMetadata | undefined;
  basic?: XmpBasicMetadata | undefined;
  pdf?: XmpPdfMetadata | undefined;
  dublinCore?: XmpDublinCoreMetadata | undefined;
  pdfAExtensions?: XmpPdfAExtensionsMetadata | undefined;
  facturX?: XmpFacturXMetadata | undefined;

  [key: string]: any;

  constructor(data?: IXmpMetadata) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
      this.pdfAIdentification =
        data.pdfAIdentification && !(<any>data.pdfAIdentification).toJSON
          ? new XmpPdfAIdentificationMetadata(data.pdfAIdentification)
          : <XmpPdfAIdentificationMetadata>this.pdfAIdentification;
      this.basic = data.basic && !(<any>data.basic).toJSON ? new XmpBasicMetadata(data.basic) : <XmpBasicMetadata>this.basic;
      this.pdf = data.pdf && !(<any>data.pdf).toJSON ? new XmpPdfMetadata(data.pdf) : <XmpPdfMetadata>this.pdf;
      this.dublinCore = data.dublinCore && !(<any>data.dublinCore).toJSON ? new XmpDublinCoreMetadata(data.dublinCore) : <XmpDublinCoreMetadata>this.dublinCore;
      this.pdfAExtensions =
        data.pdfAExtensions && !(<any>data.pdfAExtensions).toJSON ? new XmpPdfAExtensionsMetadata(data.pdfAExtensions) : <XmpPdfAExtensionsMetadata>this.pdfAExtensions;
      this.facturX = data.facturX && !(<any>data.facturX).toJSON ? new XmpFacturXMetadata(data.facturX) : <XmpFacturXMetadata>this.facturX;
    }
  }

  init(_data?: any) {
    if (_data) {
      for (var property in _data) {
        if (_data.hasOwnProperty(property)) this[property] = _data[property];
      }
      this.pdfAIdentification = _data['pdfAIdentification'] ? XmpPdfAIdentificationMetadata.fromJS(_data['pdfAIdentification']) : <any>undefined;
      this.basic = _data['basic'] ? XmpBasicMetadata.fromJS(_data['basic']) : <any>undefined;
      this.pdf = _data['pdf'] ? XmpPdfMetadata.fromJS(_data['pdf']) : <any>undefined;
      this.dublinCore = _data['dublinCore'] ? XmpDublinCoreMetadata.fromJS(_data['dublinCore']) : <any>undefined;
      this.pdfAExtensions = _data['pdfAExtensions'] ? XmpPdfAExtensionsMetadata.fromJS(_data['pdfAExtensions']) : <any>undefined;
      this.facturX = _data['facturX'] ? XmpFacturXMetadata.fromJS(_data['facturX']) : <any>undefined;
    }
  }

  static fromJS(data: any): XmpMetadata {
    data = typeof data === 'object' ? data : {};
    let result = new XmpMetadata();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    for (var property in this) {
      if (this.hasOwnProperty(property)) data[property] = this[property];
    }
    data['pdfAIdentification'] = this.pdfAIdentification ? this.pdfAIdentification.toJSON() : <any>undefined;
    data['basic'] = this.basic ? this.basic.toJSON() : <any>undefined;
    data['pdf'] = this.pdf ? this.pdf.toJSON() : <any>undefined;
    data['dublinCore'] = this.dublinCore ? this.dublinCore.toJSON() : <any>undefined;
    data['pdfAExtensions'] = this.pdfAExtensions ? this.pdfAExtensions.toJSON() : <any>undefined;
    data['facturX'] = this.facturX ? this.facturX.toJSON() : <any>undefined;
    return data;
  }
}

export interface IXmpMetadata {
  pdfAIdentification?: IXmpPdfAIdentificationMetadata | undefined;
  basic?: IXmpBasicMetadata | undefined;
  pdf?: IXmpPdfMetadata | undefined;
  dublinCore?: IXmpDublinCoreMetadata | undefined;
  pdfAExtensions?: IXmpPdfAExtensionsMetadata | undefined;
  facturX?: IXmpFacturXMetadata | undefined;

  [key: string]: any;
}

export class XmpPdfAExtensionsMetadata implements IXmpPdfAExtensionsMetadata {
  schemas?: XmpPdfASchemaMetadata[];

  [key: string]: any;

  constructor(data?: IXmpPdfAExtensionsMetadata) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
      if (data.schemas) {
        this.schemas = [];
        for (let i = 0; i < data.schemas.length; i++) {
          let item = data.schemas[i];
          this.schemas[i] = item && !(<any>item).toJSON ? new XmpPdfASchemaMetadata(item) : <XmpPdfASchemaMetadata>item;
        }
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      for (var property in _data) {
        if (_data.hasOwnProperty(property)) this[property] = _data[property];
      }
      if (Array.isArray(_data['schemas'])) {
        this.schemas = [] as any;
        for (let item of _data['schemas']) this.schemas!.push(XmpPdfASchemaMetadata.fromJS(item));
      }
    }
  }

  static fromJS(data: any): XmpPdfAExtensionsMetadata {
    data = typeof data === 'object' ? data : {};
    let result = new XmpPdfAExtensionsMetadata();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    for (var property in this) {
      if (this.hasOwnProperty(property)) data[property] = this[property];
    }
    if (Array.isArray(this.schemas)) {
      data['schemas'] = [];
      for (let item of this.schemas) data['schemas'].push(item.toJSON());
    }
    return data;
  }
}

export interface IXmpPdfAExtensionsMetadata {
  schemas?: IXmpPdfASchemaMetadata[];

  [key: string]: any;
}

export class XmpPdfAFieldMetadata implements IXmpPdfAFieldMetadata {
  description?: string | undefined;
  name?: string | undefined;
  valueType?: string | undefined;

  [key: string]: any;

  constructor(data?: IXmpPdfAFieldMetadata) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      for (var property in _data) {
        if (_data.hasOwnProperty(property)) this[property] = _data[property];
      }
      this.description = _data['description'];
      this.name = _data['name'];
      this.valueType = _data['valueType'];
    }
  }

  static fromJS(data: any): XmpPdfAFieldMetadata {
    data = typeof data === 'object' ? data : {};
    let result = new XmpPdfAFieldMetadata();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    for (var property in this) {
      if (this.hasOwnProperty(property)) data[property] = this[property];
    }
    data['description'] = this.description;
    data['name'] = this.name;
    data['valueType'] = this.valueType;
    return data;
  }
}

export interface IXmpPdfAFieldMetadata {
  description?: string | undefined;
  name?: string | undefined;
  valueType?: string | undefined;

  [key: string]: any;
}

export class XmpPdfAIdentificationMetadata implements IXmpPdfAIdentificationMetadata {
  amendment?: string | undefined;
  conformance?: XmpPdfAConformanceLevel | undefined;
  part?: number | undefined;

  [key: string]: any;

  constructor(data?: IXmpPdfAIdentificationMetadata) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      for (var property in _data) {
        if (_data.hasOwnProperty(property)) this[property] = _data[property];
      }
      this.amendment = _data['amendment'];
      this.conformance = _data['conformance'];
      this.part = _data['part'];
    }
  }

  static fromJS(data: any): XmpPdfAIdentificationMetadata {
    data = typeof data === 'object' ? data : {};
    let result = new XmpPdfAIdentificationMetadata();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    for (var property in this) {
      if (this.hasOwnProperty(property)) data[property] = this[property];
    }
    data['amendment'] = this.amendment;
    data['conformance'] = this.conformance;
    data['part'] = this.part;
    return data;
  }
}

export interface IXmpPdfAIdentificationMetadata {
  amendment?: string | undefined;
  conformance?: XmpPdfAConformanceLevel | undefined;
  part?: number | undefined;

  [key: string]: any;
}

export class XmpPdfAPropertyMetadata implements IXmpPdfAPropertyMetadata {
  category?: XmpPdfAPropertyCategory | undefined;
  description?: string | undefined;
  name?: string | undefined;
  valueType?: string | undefined;

  [key: string]: any;

  constructor(data?: IXmpPdfAPropertyMetadata) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      for (var property in _data) {
        if (_data.hasOwnProperty(property)) this[property] = _data[property];
      }
      this.category = _data['category'];
      this.description = _data['description'];
      this.name = _data['name'];
      this.valueType = _data['valueType'];
    }
  }

  static fromJS(data: any): XmpPdfAPropertyMetadata {
    data = typeof data === 'object' ? data : {};
    let result = new XmpPdfAPropertyMetadata();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    for (var property in this) {
      if (this.hasOwnProperty(property)) data[property] = this[property];
    }
    data['category'] = this.category;
    data['description'] = this.description;
    data['name'] = this.name;
    data['valueType'] = this.valueType;
    return data;
  }
}

export interface IXmpPdfAPropertyMetadata {
  category?: XmpPdfAPropertyCategory | undefined;
  description?: string | undefined;
  name?: string | undefined;
  valueType?: string | undefined;

  [key: string]: any;
}

export class XmpPdfASchemaMetadata implements IXmpPdfASchemaMetadata {
  namespaceUri?: string | undefined;
  prefix?: string | undefined;
  property?: XmpPdfAPropertyMetadata[];
  schema?: string | undefined;
  valueType?: XmpPdfATypeMetadata[];

  [key: string]: any;

  constructor(data?: IXmpPdfASchemaMetadata) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
      if (data.property) {
        this.property = [];
        for (let i = 0; i < data.property.length; i++) {
          let item = data.property[i];
          this.property[i] = item && !(<any>item).toJSON ? new XmpPdfAPropertyMetadata(item) : <XmpPdfAPropertyMetadata>item;
        }
      }
      if (data.valueType) {
        this.valueType = [];
        for (let i = 0; i < data.valueType.length; i++) {
          let item = data.valueType[i];
          this.valueType[i] = item && !(<any>item).toJSON ? new XmpPdfATypeMetadata(item) : <XmpPdfATypeMetadata>item;
        }
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      for (var property in _data) {
        if (_data.hasOwnProperty(property)) this[property] = _data[property];
      }
      this.namespaceUri = _data['namespaceUri'];
      this.prefix = _data['prefix'];
      if (Array.isArray(_data['property'])) {
        this.property = [] as any;
        for (let item of _data['property']) this.property!.push(XmpPdfAPropertyMetadata.fromJS(item));
      }
      this.schema = _data['schema'];
      if (Array.isArray(_data['valueType'])) {
        this.valueType = [] as any;
        for (let item of _data['valueType']) this.valueType!.push(XmpPdfATypeMetadata.fromJS(item));
      }
    }
  }

  static fromJS(data: any): XmpPdfASchemaMetadata {
    data = typeof data === 'object' ? data : {};
    let result = new XmpPdfASchemaMetadata();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    for (var property in this) {
      if (this.hasOwnProperty(property)) data[property] = this[property];
    }
    data['namespaceUri'] = this.namespaceUri;
    data['prefix'] = this.prefix;
    if (Array.isArray(this.property)) {
      data['property'] = [];
      for (let item of this.property) data['property'].push(item.toJSON());
    }
    data['schema'] = this.schema;
    if (Array.isArray(this.valueType)) {
      data['valueType'] = [];
      for (let item of this.valueType) data['valueType'].push(item.toJSON());
    }
    return data;
  }
}

export interface IXmpPdfASchemaMetadata {
  namespaceUri?: string | undefined;
  prefix?: string | undefined;
  property?: IXmpPdfAPropertyMetadata[];
  schema?: string | undefined;
  valueType?: IXmpPdfATypeMetadata[];

  [key: string]: any;
}

export class XmpPdfATypeMetadata implements IXmpPdfATypeMetadata {
  description?: string | undefined;
  field?: XmpPdfAFieldMetadata[];
  namespaceUri?: string | undefined;
  prefix?: string | undefined;
  type?: string | undefined;

  [key: string]: any;

  constructor(data?: IXmpPdfATypeMetadata) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
      if (data.field) {
        this.field = [];
        for (let i = 0; i < data.field.length; i++) {
          let item = data.field[i];
          this.field[i] = item && !(<any>item).toJSON ? new XmpPdfAFieldMetadata(item) : <XmpPdfAFieldMetadata>item;
        }
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      for (var property in _data) {
        if (_data.hasOwnProperty(property)) this[property] = _data[property];
      }
      this.description = _data['description'];
      if (Array.isArray(_data['field'])) {
        this.field = [] as any;
        for (let item of _data['field']) this.field!.push(XmpPdfAFieldMetadata.fromJS(item));
      }
      this.namespaceUri = _data['namespaceUri'];
      this.prefix = _data['prefix'];
      this.type = _data['type'];
    }
  }

  static fromJS(data: any): XmpPdfATypeMetadata {
    data = typeof data === 'object' ? data : {};
    let result = new XmpPdfATypeMetadata();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    for (var property in this) {
      if (this.hasOwnProperty(property)) data[property] = this[property];
    }
    data['description'] = this.description;
    if (Array.isArray(this.field)) {
      data['field'] = [];
      for (let item of this.field) data['field'].push(item.toJSON());
    }
    data['namespaceUri'] = this.namespaceUri;
    data['prefix'] = this.prefix;
    data['type'] = this.type;
    return data;
  }
}

export interface IXmpPdfATypeMetadata {
  description?: string | undefined;
  field?: IXmpPdfAFieldMetadata[];
  namespaceUri?: string | undefined;
  prefix?: string | undefined;
  type?: string | undefined;

  [key: string]: any;
}

export class XmpPdfMetadata implements IXmpPdfMetadata {
  keywords?: string | undefined;
  pdfVersion?: string | undefined;
  producer?: string | undefined;
  trapped?: boolean | undefined;

  [key: string]: any;

  constructor(data?: IXmpPdfMetadata) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      for (var property in _data) {
        if (_data.hasOwnProperty(property)) this[property] = _data[property];
      }
      this.keywords = _data['keywords'];
      this.pdfVersion = _data['pdfVersion'];
      this.producer = _data['producer'];
      this.trapped = _data['trapped'];
    }
  }

  static fromJS(data: any): XmpPdfMetadata {
    data = typeof data === 'object' ? data : {};
    let result = new XmpPdfMetadata();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    for (var property in this) {
      if (this.hasOwnProperty(property)) data[property] = this[property];
    }
    data['keywords'] = this.keywords;
    data['pdfVersion'] = this.pdfVersion;
    data['producer'] = this.producer;
    data['trapped'] = this.trapped;
    return data;
  }
}

export interface IXmpPdfMetadata {
  keywords?: string | undefined;
  pdfVersion?: string | undefined;
  producer?: string | undefined;
  trapped?: boolean | undefined;

  [key: string]: any;
}

export class XmpThumbnail implements IXmpThumbnail {
  format?: XmpThumbnailFormat | undefined;
  height?: number | undefined;
  width?: number | undefined;
  image?: string | undefined;

  [key: string]: any;

  constructor(data?: IXmpThumbnail) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      for (var property in _data) {
        if (_data.hasOwnProperty(property)) this[property] = _data[property];
      }
      this.format = _data['format'];
      this.height = _data['height'];
      this.width = _data['width'];
      this.image = _data['image'];
    }
  }

  static fromJS(data: any): XmpThumbnail {
    data = typeof data === 'object' ? data : {};
    let result = new XmpThumbnail();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    for (var property in this) {
      if (this.hasOwnProperty(property)) data[property] = this[property];
    }
    data['format'] = this.format;
    data['height'] = this.height;
    data['width'] = this.width;
    data['image'] = this.image;
    return data;
  }
}

export interface IXmpThumbnail {
  format?: XmpThumbnailFormat | undefined;
  height?: number | undefined;
  width?: number | undefined;
  image?: string | undefined;

  [key: string]: any;
}

export interface FileResponse {
  data: Blob;
  status: number;
  fileName?: string;
  headers?: { [name: string]: any };
}
